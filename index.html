<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JSON-UI Builder</title>
    <link rel="stylesheet" href="style.css">
</head>

<body>

    <!-- Top Navigation Bar -->
    <div class="top-navbar">
        <div class="navbar-left">
            <div class="importers">
                <label class="ui_textures_importer">
                    <input title="Import Textures" type="file" id="ui_textures_importer"
                        onchange="Builder.handleUiTexturesUpload()" webkitdirectory directory multiple />
                    Import Textures
                </label>

                <label class="form_importer">
                    <input title="Upload Form" type="file" id="form_importer" onchange="Builder.uploadForm()" accept=".json" />
                    Upload Form
                </label>
            </div>
        </div>

        <div class="navbar-center">
            <!-- Authentication UI -->
            <div id="authStatus" class="auth-status-inline">
                <span id="authUserDisplay">Not signed in</span>
                <button id="authSignInBtn" onclick="Builder.openAuthModal(false)">Sign In</button>
                <button id="authSignUpBtn" onclick="Builder.openAuthModal(true)">Sign Up</button>
                <button id="authLogoutBtn" onclick="Builder.logout()" style="display: none;">Logout</button>
            </div>

            <!-- Preset buttons -->
            <button id="presetUploadBtn" onclick="Builder.openUploadPresetModal()" style="display: none;" class="navbar-preset-btn primary">Upload Preset</button>
            <button id="presetManagementBtn" onclick="Builder.openPresetManagementModal()" style="display: none;" class="navbar-preset-btn secondary">Manage Presets</button>
            <button class="navbar-preset-btn tertiary" onclick="Builder.texturePresetsModal()">Preset Textures</button>

            <div class="navbar-divider"></div>

            <button class="modalSettingsBtn" id="modalSettingsBtn">
                <span class="settings_label">Settings</span>
                <img class="settings_img" src="icons/settings_cog.webp" alt="Settings">
            </button>

            <div class="scale-control">
                <label for="ui_scale_slider" style="color: white; font-size: 12px; margin-right: 5px;">Scale:</label>
                <input id="ui_scale_slider" type="range" min="10" max="100">
            </div>

            <button id="undo-btn" onclick="Builder.undo()" disabled title="Undo (Ctrl+Z)">‚Ü∂ Undo</button>
            <button id="redo-btn" onclick="Builder.redo()" disabled title="Redo (Ctrl+Y)">‚Ü∑ Redo</button>
            
            <!-- Smart Snap Toggle -->
            <button id="snap-toggle-btn" onclick="SmartSnap.toggleSnapping()" title="Toggle Smart Snapping (S)" 
                style="padding: 8px 12px; background: linear-gradient(135deg, #00ff88, #00cc6a); color: #000; border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 6px; cursor: pointer; font-weight: 600; font-size: 12px;">
                üìè Snap: ON
            </button>
        </div>

        <div class="navbar-right">
            <img src="icons/help.webp" class="help_button" onclick="Builder.openHelpMenu()" alt="Help">
            <a href="https://discord.gg/zqfNbYCcA9" class="discord_link" target="_blank">
                <img src="icons/discord.webp" class="discord_icon" alt="Discord">
            </a>
        </div>
    </div>

    <!-- The Settings Modal -->
    <div id="modalSettings" class="modal">
        <div class="modal-content">
            <span id="modalSettingsClose" class="modalClose">&times;</span>
            <h2 class="modalHeader">Settings</h2>
            <div class="modalSettingsForm">

            </div>
        </div>
    </div>
    <!--------------->

    <!-- The Add Button Modal -->
    <div id="modalAddButton" class="modal">
        <div class="modal-content">
            <span id="modalAddButtonClose" class="modalClose">&times;</span>
            <h2 class="modalHeader">Add Button</h2>
            <div class="modalAddButtonForm">

            </div>
        </div>
    </div>
    <!--------------->

    <!-- The Create Form Modal -->
    <div id="modalCreateForm" class="modal">
        <div class="modal-content">
            <h2 class="modalHeader">Create Form</h2>
            <div class="modalCreateFormForm">

            </div>
        </div>
    </div>
    <!--------------->

    <!-- The Load Texture Presets Modal -->
    <div id="modalLoadTexturePresets" class="modal">
        <div class="modal-content">
            <span id="modalLoadTexturePresetsClose" class="modalClose">&times;</span>
            <h2 class="modalHeader">Load Texture Presets</h2>
            <div class="modalLoadTexturePresetsForm">

            </div>
        </div>
    </div>
    <!--------------->

    <!-- The Help Menu Modal -->
    <div id="modalHelpMenu" class="modal">
        <div class="modal-content">
            <span id="modalHelpMenuClose" class="modalClose">&times;</span>
            <h2 class="modalHeader">Help</h2>
            <div class="modalHelpMenuForm">
                <label style="font-weight: 500; color: rgb(255, 255, 255);">Key Binds:</label><br><br>

                <label class="modalOptionLabel">
                CTRL + c: <b>Copy</b><br>
                CTRL + v: <b>Paste</b><br>
                CTRL + x: <b>Cut</b><br>
                Tab: <b>Indent</b><br>
                Del: <b>Delete</b><br>
                Tab | Enter: <b>Autocomplete</b><br>
                Arrow Keys: <b>Move</b><br>
                S: <b>Toggle Smart Snapping</b><br>
                Q: <b>Manual Snap (Prioritizes Centers)</b><br>
                Hold Shift: <b>Disable Snapping Temporarily</b><br>
                Hold Ctrl: <b>Super Snap Mode (More Aggressive)</b>
                </label>

                <label style="font-weight: 500; color: rgb(255, 255, 255); font-size: 20px;">General
                    Issues:</label><br><br>

                <label style="font-weight: 500; color: rgb(255, 255, 255);">Why arent my buttons working
                    in-game?</label><br><br>
                <label class="modalOptionLabel">You probably need to stack the button on top of a collection panel, if
                    that doesnt fix it, check that all texture paths are correct</label><br><br>

                <label style="font-weight: 500; color: rgb(255, 255, 255);">Why isnt the form uploader
                    working?</label><br><br>
                <label class="modalOptionLabel">The form uploader can only upload forms made by the website</label>
            </div>
        </div>
    </div>
    <!--------------->

    <!-- The Choose Image Modal -->
    <div id="modalChooseImage" class="modal">
        <div class="modal-content">
            <span id="modalChooseImageClose" class="modalClose">&times;</span>
            <h2 class="modalHeader">Choose Image</h2>
            <img src="icons/nineslice.webp" style="width: 20px; position: relative; top: 5px; left: 5px;" alt="Nineslice">
            <label style="font-weight: 500; color: rgb(255, 255, 255);">: Nineslice Image</label>
            <div class="modalChooseImageForm">

            </div>
        </div>
    </div>
    <!--------------->

    <div class="main">
        <div class="buttons">
            <div class="addElements">
                Elements:
                <button type="button" onclick="Builder.addPanel()">Add panel</button>
                <button type="button" onclick="Builder.openAddImageMenu()">Add image</button>
                <button type="button" onclick="Builder.addButton()">Add button</button>
                <button type="button" onclick="Builder.addCollectionPanel()">Add Collection Panel</button>
                <button type="button" onclick="Builder.addLabel()">Add Label</button>
                <button type="button" onclick="Builder.addScrollingPanel()">Add Scrolling Panel</button>
            </div>

            <div class="breaker"></div>

            <div class="utilElements">
                <button class="utilElement" type="button" onclick="Builder.reset()">Reset <img
                        style="width: 17px; top: 3px; position: relative; filter: drop-shadow(0px 0px 5px #000000);"
                        src="icons/reset.webp" alt="Reset"> </button>
                <button class="utilElement" type="button" onclick="Builder.deleteSelected()">Delete Selected <img
                        style="width: 20px; top: 3px; position: relative; filter: drop-shadow(0px 0px 5px #000000);"
                        src="icons/bin.webp" alt="Delete"> </button>

                <div style="display:flex; flex-direction: row; justify-content: center; align-items: center">
                    <div class="utilElement" style="width: 100%;">Form</div>

                    <img class="utilElement" title="Copy" onclick="Builder.generateAndCopyJsonUI('copy')"
                        style="width: 20px; position: relative; filter: drop-shadow(0px 0px 5px #000000); cursor: pointer;"
                        src="icons/clipboard.webp" alt="Copy">
                    <img class="utilElement" title="Download" onclick="Builder.generateAndCopyJsonUI('download')"
                        style="width: 20px; position: relative; filter: drop-shadow(0px 0px 5px #000000); cursor: pointer;"
                        src="icons/download.webp" alt="Download">
                </div>

                <div style="display:flex; flex-direction: row; justify-content: center; align-items: center">
                    <div class="utilElement" style="width: 100%;">Server-Form</div>

                    <img class="utilElement" title="Copy" onclick="Builder.downloadServerForm('copy')"
                        style="width: 20px; position: relative; filter: drop-shadow(0px 0px 5px #000000); cursor: pointer;"
                        src="icons/clipboard.webp" alt="Copy">
                    <img class="utilElement" title="Download" onclick="Builder.downloadServerForm('download')"
                        style="width: 20px; position: relative; filter: drop-shadow(0px 0px 5px #000000); cursor: pointer;"
                        src="icons/download.webp" alt="Download">
                </div>

            </div>

            <div class="breaker"></div>

            <div id="explorer" class="explorer"></div>

        </div>

        <div class="main_window_outline">
            <div class="main_window" id="main_window">
                <img title="Background" src="background.png" width="100%" height="100%" class="bg_image" id="bg_image" alt="Background">
            </div>
        </div>

        <div class="scripter">
            <div class="scripter_title_label">Script</div>

            <div style="color: rgb(139, 139, 139);">For Fixed Collection Index Forms Only</div>
            <div class="scripter_buttons">
                <button class="generate_js_scripter" id="generate_js_scripter">Copy <img
                        style="width: 18px; top: 3px; position: relative; filter: drop-shadow(0px 0px 5px #000000);"
                        src="icons/js.webp" alt="JavaScript"> To Clipboard</button>
                <button class="generate_ts_scripter" id="generate_ts_scripter">Copy <img
                        style="width: 18px; top: 3px; position: relative; filter: drop-shadow(0px 0px 5px #000000);"
                        src="icons/ts.webp" alt="TypeScript"> To Clipboard</button>
            </div>

            <br><br><br>

            <div class="scripter_title_label">Bindings</div>
            <div style="color: rgb(139, 139, 139);">Advanced Feature</div>
            <div id="errorMessage" title="Default Error Message" style="visibility: hidden; color: #7e0000;">Warnings ‚ö†Ô∏è
            </div>
            <textarea spellcheck="false" readonly class="bindings" id="bindings"></textarea>

            <div style="display:flex; flex-direction: row; justify-content: center; align-items: center">
                <div style="font-size: 20px; color: rgb(39, 165, 255);">TAB</div>&nbsp To indent
                <div onclick="Builder.formatBindingsArea()" style="position: relative; margin-left: 15px; cursor: pointer;"
                    class="utilElement">Format <img
                        style="width: 20px; top: 3px; position: relative; filter: drop-shadow(0px 0px 5px #000000);"
                        src="icons/curly_brackets.webp" alt="Format"></div>
            </div>
        </div>
    </div>

    <div id="properties" class="properties"></div>

    <div id="notif-container"></div>

    <div id="mainWarningMessage"></div>

    <!-- Smart Snapping Visual Guides Container -->
    <div id="snap-guides-container" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 9998;"></div>

    <script src="./dist/index.js" type="module"></script>

    <style>
        /* Top Navigation Bar */
        .top-navbar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            min-height: 60px;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.95), rgba(20, 20, 20, 0.95));
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(10px);
            z-index: 999;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 15px;
            flex-wrap: wrap;
            gap: 10px;
        }

        .navbar-left,
        .navbar-center,
        .navbar-right {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .navbar-center {
            flex: 1;
            justify-content: center;
            flex-wrap: wrap;
            gap: 10px;
        }

        .navbar-divider {
            width: 1px;
            height: 30px;
            background: rgba(255, 255, 255, 0.2);
            margin: 0 5px;
        }

        .navbar-right {
            gap: 15px;
        }

        .scale-control {
            display: flex;
            align-items: center;
        }

        .importers {
            display: flex;
            gap: 10px;
        }

        #undo-btn,
        #redo-btn {
            font-size: 13px;
            padding: 8px 12px;
            background: linear-gradient(135deg, #444, #333);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
            white-space: nowrap;
        }

        #undo-btn:hover:not(:disabled),
        #redo-btn:hover:not(:disabled) {
            background: linear-gradient(135deg, #555, #444);
            transform: translateY(-1px);
        }

        #undo-btn:disabled,
        #redo-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .help_button,
        .discord_icon {
            width: 32px;
            height: 32px;
            cursor: pointer;
            transition: transform 0.3s ease, filter 0.3s ease;
            filter: drop-shadow(0px 0px 5px rgba(0, 0, 0, 0.5));
        }

        .help_button:hover,
        .discord_icon:hover {
            transform: scale(1.1);
            filter: drop-shadow(0px 0px 8px rgba(255, 255, 255, 0.3));
        }

        .discord_link {
            display: flex;
            align-items: center;
        }

        /* Authentication Status - Inline in navbar */
        .auth-status-inline {
            display: flex;
            align-items: center;
            gap: 8px;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.6), rgba(20, 20, 20, 0.6));
            padding: 6px 10px;
            border-radius: 6px;
            border: 1px solid rgba(255, 255, 255, 0.15);
        }

        .auth-status-inline span {
            color: white;
            font-size: 12px;
            font-weight: 500;
            white-space: nowrap;
        }

        .auth-status-inline button {
            padding: 6px 12px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 11px;
            font-weight: 600;
            transition: all 0.3s ease;
            white-space: nowrap;
        }

        #authSignInBtn,
        #authSignUpBtn {
            background: linear-gradient(135deg, #007bff, #0056b3);
            color: white;
        }

        #authSignInBtn:hover,
        #authSignUpBtn:hover {
            background: linear-gradient(135deg, #0056b3, #004085);
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0, 123, 255, 0.3);
        }

        #authLogoutBtn {
            background: linear-gradient(135deg, #dc3545, #c82333);
            color: white;
        }

        #authLogoutBtn:hover {
            background: linear-gradient(135deg, #c82333, #bd2130);
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(220, 53, 69, 0.3);
        }

        /* Preset buttons in navbar */
        .navbar-preset-btn {
            padding: 8px 14px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 600;
            transition: all 0.3s ease;
            white-space: nowrap;
        }

        .navbar-preset-btn.primary {
            background: linear-gradient(135deg, #28a745, #218838);
            color: white;
        }

        .navbar-preset-btn.primary:hover {
            background: linear-gradient(135deg, #218838, #1e7e34);
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(40, 167, 69, 0.3);
        }

        .navbar-preset-btn.secondary {
            background: linear-gradient(135deg, #17a2b8, #138496);
            color: white;
        }

        .navbar-preset-btn.secondary:hover {
            background: linear-gradient(135deg, #138496, #117a8b);
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(23, 162, 184, 0.3);
        }

        .navbar-preset-btn.tertiary {
            background: linear-gradient(135deg, #6f42c1, #5a32a3);
            color: white;
        }

        .navbar-preset-btn.tertiary:hover {
            background: linear-gradient(135deg, #5a32a3, #4c2a8a);
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(111, 66, 193, 0.3);
        }

        /* Adjust main content to account for navbar */
        .main {
            margin-top: 70px;
        }

        /* Responsive adjustments */
        @media (max-width: 1600px) {
            .navbar-center {
                max-width: none;
            }
        }

        @media (max-width: 1200px) {
            .auth-status-inline span {
                display: none;
            }
        }

        @media (max-width: 768px) {
            .top-navbar {
                flex-direction: column;
                padding: 10px;
            }

            .navbar-left,
            .navbar-center,
            .navbar-right {
                width: 100%;
                justify-content: center;
                flex-wrap: wrap;
            }

            .navbar-divider {
                display: none;
            }

            .main {
                margin-top: 160px;
            }
        }

        /* ==================== SMART SNAPPING STYLES ==================== */
        
        /* Snap Visual Guide Lines */
        .snap-guide-line {
            position: absolute;
            pointer-events: none;
            z-index: 9999;
            opacity: 0;
            transition: opacity 0.15s ease-in-out;
        }

        .snap-guide-line.active {
            opacity: 1;
        }

        .snap-guide-line.horizontal {
            height: 2px;
            background: linear-gradient(90deg, 
                transparent 0%, 
                #00ff88 10%, 
                #00ff88 90%, 
                transparent 100%);
            box-shadow: 0 0 8px rgba(0, 255, 136, 0.6),
                        0 0 15px rgba(0, 255, 136, 0.3);
            width: 100%;
            left: 0;
        }

        .snap-guide-line.vertical {
            width: 2px;
            background: linear-gradient(180deg, 
                transparent 0%, 
                #00ff88 10%, 
                #00ff88 90%, 
                transparent 100%);
            box-shadow: 0 0 8px rgba(0, 255, 136, 0.6),
                        0 0 15px rgba(0, 255, 136, 0.3);
            height: 100%;
            top: 0;
        }

        /* Snap Point Indicators */
        .snap-point-indicator {
            position: absolute;
            width: 8px;
            height: 8px;
            background: #00ff88;
            border: 2px solid #fff;
            border-radius: 50%;
            pointer-events: none;
            z-index: 10000;
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.8),
                        0 0 20px rgba(0, 255, 136, 0.4);
            transform: translate(-50%, -50%);
            animation: snapPointPulse 0.8s ease-in-out infinite;
        }

        @keyframes snapPointPulse {
            0%, 100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
            50% { transform: translate(-50%, -50%) scale(1.3); opacity: 0.7; }
        }

        /* Snap Distance Indicator */
        .snap-distance-indicator {
            position: absolute;
            background: rgba(0, 255, 136, 0.15);
            border: 1px dashed #00ff88;
            pointer-events: none;
            z-index: 9997;
            opacity: 0;
            transition: opacity 0.15s ease-in-out;
        }

        .snap-distance-indicator.active {
            opacity: 1;
        }

        /* Enhanced Dragging State */
        .smart-snap-dragging {
            cursor: grabbing !important;
            opacity: 0.85;
            filter: drop-shadow(0 4px 12px rgba(0, 255, 136, 0.3));
            transition: filter 0.15s ease;
        }

        .smart-snap-snapped {
            filter: drop-shadow(0 0 15px rgba(0, 255, 136, 0.5)) !important;
        }

        /* Snap Toggle Button States */
        #snap-toggle-btn {
            transition: all 0.3s ease;
        }

        #snap-toggle-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0, 255, 136, 0.4);
        }

        #snap-toggle-btn.disabled {
            background: linear-gradient(135deg, #666, #555) !important;
            color: #999 !important;
        }

        /* Enhanced cursor styles for better UX */
        .draggable-panel,
        .draggable-canvas,
        .draggable-button,
        .draggable-collection_panel,
        .draggable-label,
        .draggable-scrolling_panel,
        [class*="draggable-"] {
            cursor: grab !important;
            transition: transform 0.1s ease, filter 0.1s ease;
        }

        .draggable-panel:hover,
        .draggable-canvas:hover,
        .draggable-button:hover,
        .draggable-collection_panel:hover,
        .draggable-label:hover,
        .draggable-scrolling_panel:hover,
        [class*="draggable-"]:hover {
            filter: brightness(1.1);
        }

        .draggable-panel:active,
        .draggable-canvas:active,
        .draggable-button:active,
        .draggable-collection_panel:active,
        .draggable-label:active,
        .draggable-scrolling_panel:active,
        [class*="draggable-"]:active {
            cursor: grabbing !important;
        }

        /* Snap Info Tooltip */
        .snap-info-tooltip {
            position: fixed;
            background: rgba(0, 0, 0, 0.9);
            color: #00ff88;
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 11px;
            font-weight: 600;
            pointer-events: none;
            z-index: 10001;
            white-space: nowrap;
            border: 1px solid #00ff88;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
            opacity: 0;
            transition: opacity 0.2s ease;
        }

        .snap-info-tooltip.active {
            opacity: 1;
        }

        /* Grid Snap Visualization */
        .snap-grid-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 9996;
            opacity: 0;
            transition: opacity 0.3s ease;
            background-image: 
                repeating-linear-gradient(0deg, 
                    transparent, 
                    transparent 9px, 
                    rgba(0, 255, 136, 0.1) 9px, 
                    rgba(0, 255, 136, 0.1) 10px),
                repeating-linear-gradient(90deg, 
                    transparent, 
                    transparent 9px, 
                    rgba(0, 255, 136, 0.1) 9px, 
                    rgba(0, 255, 136, 0.1) 10px);
        }

        .snap-grid-overlay.active {
            opacity: 1;
        }
    </style>

<script>
// IMPROVED Smart Snapping System - Less Aggressive, Smarter Priorities
const SmartSnap = {
    enabled: true,
    snapThreshold: 15, // Reduced from 25 to 15 for less aggressive snapping
    snapPoints: [],
    currentlyDragging: null,
    shiftKeyPressed: false,
    ctrlKeyPressed: false, // For "super snap" mode
    isDragging: false,
    dragInterval: null,
    dragMoveCount: 0, // Track how much the element has moved
    
    config: {
        snapToElements: true,
        snapToCanvas: true,
        showGuides: true,
        snapTolerance: 15, // Reduced from 25
        superSnapTolerance: 30, // Larger tolerance when Ctrl is held
        minDragDistance: 5, // Don't snap until dragged at least 5px
        prioritizeCenters: true, // Prioritize center-to-center snaps
    },

    init() {
        this.createGuideLines();
        this.attachEventListeners();
        this.interceptDragEvents();
        console.log('‚úÖ Smart Snapping System Initialized');
    },

    createGuideLines() {
        const container = document.getElementById('snap-guides-container');
        if (!container) return;

        ['horizontal', 'vertical'].forEach(type => {
            for (let i = 0; i < 4; i++) {
                const guide = document.createElement('div');
                guide.className = `snap-guide-line ${type}`;
                guide.setAttribute('data-guide-id', `${type}-${i}`);
                container.appendChild(guide);
            }
        });

        const tooltip = document.createElement('div');
        tooltip.className = 'snap-info-tooltip';
        tooltip.id = 'snap-tooltip';
        document.body.appendChild(tooltip);
    },

    attachEventListeners() {
        // Toggle snapping with 'S' key
        document.addEventListener('keydown', (e) => {
            if (e.key === 's' || e.key === 'S') {
                if (!e.target.matches('input, textarea')) {
                    e.preventDefault();
                    this.toggleSnapping();
                }
            }
            
            // Manual snap with 'Q' key
            if (e.key === 'q' || e.key === 'Q') {
                if (!e.target.matches('input, textarea')) {
                    e.preventDefault();
                    this.manualSnapSelected();
                }
            }
            
            // Shift to disable snapping
            if (e.key === 'Shift') {
                this.shiftKeyPressed = true;
            }
            
            // Ctrl for "super snap" mode (more aggressive)
            if (e.key === 'Control') {
                this.ctrlKeyPressed = true;
            }
        });

        document.addEventListener('keyup', (e) => {
            if (e.key === 'Shift') {
                this.shiftKeyPressed = false;
            }
            if (e.key === 'Control') {
                this.ctrlKeyPressed = false;
            }
        });
    },

    interceptDragEvents() {
        const mainWindow = document.getElementById('main_window');
        if (!mainWindow) {
            setTimeout(() => this.interceptDragEvents(), 500);
            return;
        }

        let dragStartX = 0;
        let dragStartY = 0;

        mainWindow.addEventListener('mousedown', (e) => {
            const target = e.target.closest('[class*="draggable-"]');
            if (target && e.button === 0) {
                const rect = target.getBoundingClientRect();
                dragStartX = rect.left;
                dragStartY = rect.top;
                this.startDragMonitoring(target, dragStartX, dragStartY);
            }
        }, true);

        document.addEventListener('mouseup', () => {
            this.stopDragMonitoring();
        }, true);
    },

    startDragMonitoring(element, startX, startY) {
        this.currentlyDragging = element;
        this.isDragging = true;
        this.dragMoveCount = 0;
        this.dragStartX = startX;
        this.dragStartY = startY;
        element.classList.add('smart-snap-dragging');
        
        // Update snap points once at start
        this.updateSnapPoints(element);
        
        if (this.dragInterval) {
            clearInterval(this.dragInterval);
        }
        
        // Check every 16ms (~60fps) during drag
        this.dragInterval = setInterval(() => {
            if (this.isDragging && this.currentlyDragging) {
                this.applySmartSnap(this.currentlyDragging);
            }
        }, 16);
    },

    stopDragMonitoring() {
        if (this.dragInterval) {
            clearInterval(this.dragInterval);
            this.dragInterval = null;
        }
        
        if (this.currentlyDragging) {
            this.currentlyDragging.classList.remove('smart-snap-dragging', 'smart-snap-snapped');
            this.currentlyDragging = null;
        }
        
        this.isDragging = false;
        this.dragMoveCount = 0;
        this.hideAllGuides();
        this.hideTooltip();
        
        setTimeout(() => this.updateSnapPoints(), 100);
    },

    applySmartSnap(element) {
        if (!element || !this.enabled || this.shiftKeyPressed) {
            this.hideAllGuides();
            return;
        }

        const mainWindow = document.getElementById('main_window');
        if (!mainWindow) return;

        const containerRect = mainWindow.getBoundingClientRect();
        const rect = element.getBoundingClientRect();
        
        // Check if element has moved enough to start snapping
        const movedDistance = Math.sqrt(
            Math.pow(rect.left - this.dragStartX, 2) + 
            Math.pow(rect.top - this.dragStartY, 2)
        );
        
        if (movedDistance < this.config.minDragDistance) {
            return; // Don't snap until moved at least minDragDistance
        }
        
        // Determine snap tolerance (higher if Ctrl is held)
        const snapTolerance = this.ctrlKeyPressed ? 
            this.config.superSnapTolerance : 
            this.config.snapTolerance;

        let currentLeft = parseFloat(element.style.left) || 0;
        let currentTop = parseFloat(element.style.top) || 0;

        const elementBounds = {
            left: rect.left - containerRect.left,
            right: rect.right - containerRect.left,
            top: rect.top - containerRect.top,
            bottom: rect.bottom - containerRect.top,
            centerX: (rect.left + rect.right) / 2 - containerRect.left,
            centerY: (rect.top + rect.bottom) / 2 - containerRect.top,
            width: rect.width,
            height: rect.height
        };

        // Find ALL possible snaps and prioritize
        let xSnaps = [];
        let ySnaps = [];

        for (const point of this.snapPoints) {
            // X-axis snap candidates
            const xCandidates = [
                { type: 'center', pos: point.centerX, offset: point.centerX - elementBounds.centerX, label: 'C‚ÜîC', priority: 1 },
                { type: 'left', pos: point.left, offset: point.left - elementBounds.left, label: 'L‚ÜíL', priority: 2 },
                { type: 'right', pos: point.right, offset: point.right - elementBounds.right, label: 'R‚ÜíR', priority: 2 },
                { type: 'left-right', pos: point.right, offset: point.right - elementBounds.left, label: 'L‚ÜíR', priority: 3 },
                { type: 'right-left', pos: point.left, offset: point.left - elementBounds.right, label: 'R‚ÜíL', priority: 3 },
            ];

            xCandidates.forEach(candidate => {
                if (Math.abs(candidate.offset) < snapTolerance) {
                    xSnaps.push({ ...candidate, distance: Math.abs(candidate.offset) });
                }
            });

            // Y-axis snap candidates
            const yCandidates = [
                { type: 'center', pos: point.centerY, offset: point.centerY - elementBounds.centerY, label: 'C‚ÜïC', priority: 1 },
                { type: 'top', pos: point.top, offset: point.top - elementBounds.top, label: 'T‚ÜíT', priority: 2 },
                { type: 'bottom', pos: point.bottom, offset: point.bottom - elementBounds.bottom, label: 'B‚ÜíB', priority: 2 },
                { type: 'top-bottom', pos: point.bottom, offset: point.bottom - elementBounds.top, label: 'T‚ÜíB', priority: 3 },
                { type: 'bottom-top', pos: point.top, offset: point.top - elementBounds.bottom, label: 'B‚ÜíT', priority: 3 },
            ];

            yCandidates.forEach(candidate => {
                if (Math.abs(candidate.offset) < snapTolerance) {
                    ySnaps.push({ ...candidate, distance: Math.abs(candidate.offset) });
                }
            });
        }

        // Sort by priority (center first), then by distance (closest first)
        xSnaps.sort((a, b) => {
            if (this.config.prioritizeCenters) {
                if (a.priority !== b.priority) return a.priority - b.priority;
            }
            return a.distance - b.distance;
        });

        ySnaps.sort((a, b) => {
            if (this.config.prioritizeCenters) {
                if (a.priority !== b.priority) return a.priority - b.priority;
            }
            return a.distance - b.distance;
        });

        // Take the best snap for each axis
        let bestSnapX = xSnaps[0];
        let bestSnapY = ySnaps[0];

        let snapInfo = [];
        let guidePositions = { horizontal: [], vertical: [] };

        // Apply snapping
        if (bestSnapX || bestSnapY) {
            if (bestSnapX) {
                element.style.left = (currentLeft + bestSnapX.offset) + 'px';
                guidePositions.vertical.push(bestSnapX.pos);
                snapInfo.push(bestSnapX.label);
            }
            if (bestSnapY) {
                element.style.top = (currentTop + bestSnapY.offset) + 'px';
                guidePositions.horizontal.push(bestSnapY.pos);
                snapInfo.push(bestSnapY.label);
            }

            // Show visual feedback
            if (guidePositions.vertical.length > 0) {
                this.showGuides('vertical', guidePositions.vertical);
            }
            if (guidePositions.horizontal.length > 0) {
                this.showGuides('horizontal', guidePositions.horizontal);
            }

            element.classList.add('smart-snap-snapped');
            
            // Show tooltip with mode indicator
            const mode = this.ctrlKeyPressed ? ' [SUPER SNAP]' : '';
            const mainWindowRect = mainWindow.getBoundingClientRect();
            this.showTooltip(
                rect.left - mainWindowRect.left + rect.width / 2,
                rect.top - mainWindowRect.top - 30,
                snapInfo.join(' | ') + mode
            );
        } else {
            element.classList.remove('smart-snap-snapped');
            this.hideAllGuides();
            this.hideTooltip();
        }
    },

    manualSnapSelected() {
        const mainWindow = document.getElementById('main_window');
        if (!mainWindow) return;

        const selected = mainWindow.querySelector('.selected, [data-selected="true"]') ||
                        mainWindow.querySelector('[class*="draggable-"]:last-child');
        
        if (selected) {
            this.updateSnapPoints(selected);
            this.currentlyDragging = selected;
            
            // Force prioritize centers for manual snap
            const oldPrioritize = this.config.prioritizeCenters;
            this.config.prioritizeCenters = true;
            
            // Temporarily increase snap tolerance for manual snap
            const oldTolerance = this.config.snapTolerance;
            this.config.snapTolerance = 50;
            
            this.dragStartX = selected.getBoundingClientRect().left;
            this.dragStartY = selected.getBoundingClientRect().top;
            
            this.applySmartSnap(selected);
            
            // Restore settings
            this.config.prioritizeCenters = oldPrioritize;
            this.config.snapTolerance = oldTolerance;
            
            setTimeout(() => {
                this.hideAllGuides();
                this.hideTooltip();
                if (this.currentlyDragging) {
                    this.currentlyDragging.classList.remove('smart-snap-snapped');
                }
                this.currentlyDragging = null;
            }, 1500);
            
            console.log('üìè Manual snap applied (prioritizing centers)');
        } else {
            console.log('‚ö†Ô∏è No element selected for manual snap');
        }
    },

    updateSnapPoints(excludeElement = null) {
        this.snapPoints = [];
        const mainWindow = document.getElementById('main_window');
        if (!mainWindow) return;

        const containerRect = mainWindow.getBoundingClientRect();
        
        if (this.config.snapToCanvas) {
            this.snapPoints.push({
                type: 'canvas',
                left: 0,
                right: containerRect.width,
                top: 0,
                bottom: containerRect.height,
                centerX: containerRect.width / 2,
                centerY: containerRect.height / 2
            });
        }

        if (this.config.snapToElements) {
            const elements = mainWindow.querySelectorAll('[class*="draggable-"]');
            elements.forEach(el => {
                if (el === excludeElement) return;
                
                const rect = el.getBoundingClientRect();
                this.snapPoints.push({
                    type: 'element',
                    element: el,
                    left: rect.left - containerRect.left,
                    right: rect.right - containerRect.left,
                    top: rect.top - containerRect.top,
                    bottom: rect.bottom - containerRect.top,
                    centerX: (rect.left + rect.right) / 2 - containerRect.left,
                    centerY: (rect.top + rect.bottom) / 2 - containerRect.top,
                });
            });
        }
    },

    showGuides(type, positions) {
        if (!this.config.showGuides) return;

        const container = document.getElementById('snap-guides-container');
        if (!container) return;

        const guides = container.querySelectorAll(`.snap-guide-line.${type}`);
        
        guides.forEach((guide, index) => {
            if (index < positions.length) {
                guide.classList.add('active');
                if (type === 'horizontal') {
                    guide.style.top = positions[index] + 'px';
                } else {
                    guide.style.left = positions[index] + 'px';
                }
            } else {
                guide.classList.remove('active');
            }
        });
    },

    hideAllGuides() {
        const container = document.getElementById('snap-guides-container');
        if (container) {
            container.querySelectorAll('.snap-guide-line').forEach(guide => {
                guide.classList.remove('active');
            });
        }
    },

    showTooltip(x, y, text) {
        const tooltip = document.getElementById('snap-tooltip');
        if (tooltip && text) {
            tooltip.textContent = 'üìè ' + text;
            tooltip.style.left = x + 'px';
            tooltip.style.top = y + 'px';
            tooltip.classList.add('active');
        }
    },

    hideTooltip() {
        const tooltip = document.getElementById('snap-tooltip');
        if (tooltip) {
            tooltip.classList.remove('active');
        }
    },

    toggleSnapping() {
        this.enabled = !this.enabled;
        const btn = document.getElementById('snap-toggle-btn');
        if (btn) {
            if (this.enabled) {
                btn.innerHTML = 'üìè Snap: ON';
                btn.style.background = 'linear-gradient(135deg, #00ff88, #00cc6a)';
                btn.style.color = '#000';
                btn.classList.remove('disabled');
            } else {
                btn.innerHTML = 'üìè Snap: OFF';
                btn.style.background = 'linear-gradient(135deg, #666, #555)';
                btn.style.color = '#999';
                btn.classList.add('disabled');
                this.hideAllGuides();
                this.hideTooltip();
            }
        }
        console.log(`Smart Snapping: ${this.enabled ? 'ENABLED ‚úÖ' : 'DISABLED ‚ùå'}`);
    }
};

// Initialize
function initializeSmartSnap() {
    if (document.getElementById('main_window')) {
        SmartSnap.init();
    } else {
        setTimeout(initializeSmartSnap, 500);
    }
}

if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initializeSmartSnap);
} else {
    initializeSmartSnap();
}

window.SmartSnap = SmartSnap;
</script>
